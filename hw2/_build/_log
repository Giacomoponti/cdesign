### Starting build.
# Target: main.ml.depends, tags: { package(num), extension:ml, file:main.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules main.ml > main.ml.depends # cached
# Target: util/assert.mli.depends, tags: { extension:mli, file:util/assert.mli, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -modules util/assert.mli > util/assert.mli.depends # cached
# Target: util/assert.cmi, tags: { byte, compile, extension:mli, file:util/assert.mli, interf, ocaml, quiet, traverse }
ocamlfind ocamlc -c -I util -I x86 -o util/assert.cmi util/assert.mli # cached
# Target: gradedtests.ml.depends, tags: { package(num), extension:ml, file:gradedtests.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules gradedtests.ml > gradedtests.ml.depends # cached
# Target: simulator.ml.depends, tags: { package(num), extension:ml, file:simulator.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules simulator.ml > simulator.ml.depends
# Target: x86/x86.ml.depends, tags: { extension:ml, file:x86/x86.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -modules x86/x86.ml > x86/x86.ml.depends # cached
# Target: x86/x86.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:x86/x86.cmo, file:x86/x86.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -I x86 -I util -o x86/x86.cmo x86/x86.ml # cached
# Target: simulator.cmo, tags: { package(num), byte, compile, extension:cmo, extension:ml, file:simulator.cmo, file:simulator.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package num -I util -I x86 -o simulator.cmo simulator.ml
+ ocamlfind ocamlc -c -package num -I util -I x86 -o simulator.cmo simulator.ml
File "simulator.ml", lines 185-190, characters 2-5:
185 | ..begin match o with
186 |     |Imm y -> invalid_arg "Dest shouldnt be imm bruh"
187 |     |Ind1 y -> (match y with | Lit l -> l | Lbl l -> failwith "Unresolved Label!")
188 |     |Ind2 y -> m.regs.(rind y)
189 |     |Ind3 (y, z) -> Int64.add (immer y) (m.regs.(rind z))
190 |   end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Reg _
File "simulator.ml", lines 233-235, characters 2-52:
233 | ..match b with
234 |     |x::[]-> m.mem.(addr) <- x  
235 |     |h::tl-> m.mem.(addr) <- h; copier tl (addr+1) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
[]
File "simulator.ml", lines 238-239, characters 2-35:
238 | ..match l with
239 |     |[x; y] -> store y (load x m) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 247-260, characters 2-11:
247 | ..match l with
248 |     |[x; y] ->
249 |       let src = load x m in
250 |       let dst = load y m in
251 |       let update = store y (Int64.add src dst) m in
...
257 |           else m.flags.fz <- false;
258 |           if (sign res = -1) then m.flags.fs <- true
259 |           else m.flags.fs <- false; 
260 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 263-276, characters 2-11:
263 | ..match l with
264 |     |[x; y] ->
265 |       let src = load x m in
266 |       let dst = load y m in
267 |       let update = store y (Int64.sub dst src) m in
...
273 |           else m.flags.fz <- false;
274 |           if (sign res = -1) then m.flags.fs <- true
275 |           else m.flags.fs <- false; 
276 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 278-285, characters 18-7:
278 | ..................(Reg y) (m:mach) : unit = 
279 |   let value = Int64.mul (m.regs.(rind x)) (m.regs.(rind y)) in
280 |     begin 
281 |       if ((sign (m.regs.(rind x)) <> sign ((m.regs.(rind y))) && sign(value) = 1) || (sign (m.regs.(rind x)) == sign ((m.regs.(rind y))) && sign(value) = -1)) 
282 |         then m.flags.fo <- true 
283 |       else m.flags.fo <- false; 
284 |       m.regs.(rind y) <- value;
285 |     end..
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 278-285, characters 10-7:
278 | ..........(Reg x) (Reg y) (m:mach) : unit = 
279 |   let value = Int64.mul (m.regs.(rind x)) (m.regs.(rind y)) in
280 |     begin 
281 |       if ((sign (m.regs.(rind x)) <> sign ((m.regs.(rind y))) && sign(value) = 1) || (sign (m.regs.(rind x)) == sign ((m.regs.(rind y))) && sign(value) = -1)) 
282 |         then m.flags.fo <- true 
283 |       else m.flags.fo <- false; 
284 |       m.regs.(rind y) <- value;
285 |     end..
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 294-306, characters 2-11:
294 | ..match l with
295 |     |[x; y] ->
296 |       let src = load x m in
297 |       let dst = load y m in
298 |       let update = store y (Int64.logand (load x m) (load y m)) m in
...
303 |           else m.flags.fz <- false;
304 |           if (sign res = -1) then m.flags.fs <- true
305 |           else m.flags.fs <- false; 
306 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 308-315, characters 16-9:
308 | ................(Reg y) (m:mach) : unit = 
309 |   let value = Int64.logor (m.regs.(rind x)) (m.regs.(rind y)) in 
310 |     let update = m.regs.(rind y) <- value  in
311 |       begin 
312 |         m.flags.fo <- false;
313 |         if (sign value = 0) then m.flags.fz <- true else m.flags.fz <- false;
314 |         if (sign value = -1) then m.flags.fs <- true else m.flags.fs <- false
315 |       end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 308-315, characters 8-9:
308 | ........(Reg x) (Reg y) (m:mach) : unit = 
309 |   let value = Int64.logor (m.regs.(rind x)) (m.regs.(rind y)) in 
310 |     let update = m.regs.(rind y) <- value  in
311 |       begin 
312 |         m.flags.fo <- false;
313 |         if (sign value = 0) then m.flags.fz <- true else m.flags.fz <- false;
314 |         if (sign value = -1) then m.flags.fs <- true else m.flags.fs <- false
315 |       end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 318-319, characters 2-79:
318 | ..match l with
319 |     |[x; y] -> store y (Int64.shift_left (load y m) (Int64.to_int(load x m))) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 322-323, characters 2-35:
322 | ..match l with
323 |     |[x; y] -> store y (load x m) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 343-365, characters 2-17:
343 | ..match l with 
344 |     |[src; dest] -> 
345 |       let move_src = movq [src; Reg R08] m in
346 |         let move_dst = movq [dest; Reg R09] m in 
347 |           let src_value = m.regs.(rind R08) in
...
362 |                 Printf.printf "%s" (Bool.to_string m.flags.fo);
363 |                 Printf.printf "%s" (Bool.to_string m.flags.fs);
364 |                 Printf.printf "%s\n" (Bool.to_string m.flags.fz);*)
365 |               end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 399-408, characters 10-13:
399 | ..........begin match opcode with 
400 |           |Imulq -> let move_src = movq [src; Reg R14] m in
401 |                     let move_dst = movq [dest; Reg R15] m in 
402 |                       let mult = imulq (Reg R14) (Reg R15) m in 
403 |                         movq [Reg R15; dest] m
404 |           | Orq -> let move_src = movq [src; Reg R14] m in
405 |                     let move_dst = movq [dest; Reg R15] m in 
406 |                       let log_or = orq (Reg R14) (Reg R15) m in 
407 |                         movq [Reg R15; dest] m
408 |           end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Movq|Pushq|Popq|Leaq|Incq|Decq|Negq|Notq|Addq|Subq|Xorq|Andq|Shlq|Sarq|Shrq|
Jmp|Cmpq|Callq|Retq|J _|Set _)
File "simulator.ml", line 242, characters 6-12:
242 |   let update = m.regs.(rind Rsp) <- (Int64.sub m.regs.(rind Rsp) 8L) in store (Ind2 Rsp) (load l m) m
            ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 251, characters 10-16:
251 |       let update = store y (Int64.add src dst) m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 267, characters 10-16:
267 |       let update = store y (Int64.sub dst src) m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 296, characters 10-13:
296 |       let src = load x m in
                ^^^
Warning 26 [unused-var]: unused variable src.
File "simulator.ml", line 297, characters 10-13:
297 |       let dst = load y m in
                ^^^
Warning 26 [unused-var]: unused variable dst.
File "simulator.ml", line 298, characters 10-16:
298 |       let update = store y (Int64.logand (load x m) (load y m)) m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 310, characters 8-14:
310 |     let update = m.regs.(rind y) <- value  in
              ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 326, characters 6-11:
326 |   let check =  if (Int64.equal (load l m) (Int64.min_int)) then m.flags.fo <- true 
            ^^^^^
Warning 26 [unused-var]: unused variable check.
File "simulator.ml", line 328, characters 6-9:
328 |   let not = notq l m in
            ^^^
Warning 26 [unused-var]: unused variable not.
File "simulator.ml", line 329, characters 6-12:
329 |   let update = store l (Int64.add (load l m) (1L)) m in
            ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 345, characters 10-18:
345 |       let move_src = movq [src; Reg R08] m in
                ^^^^^^^^
Warning 26 [unused-var]: unused variable move_src.
File "simulator.ml", line 346, characters 12-20:
346 |         let move_dst = movq [dest; Reg R09] m in 
                  ^^^^^^^^
Warning 26 [unused-var]: unused variable move_dst.
File "simulator.ml", line 349, characters 18-21:
349 |               let neg = negq (Reg R08) m in 
                        ^^^
Warning 26 [unused-var]: unused variable neg.
File "simulator.ml", line 380, characters 8-14:
380 |     let update = updater m in  
              ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 381, characters 10-13:
381 |       let mat = match instr with
                ^^^
Warning 26 [unused-var]: unused variable mat.
File "simulator.ml", line 400, characters 24-32:
400 |           |Imulq -> let move_src = movq [src; Reg R14] m in
                              ^^^^^^^^
Warning 26 [unused-var]: unused variable move_src.
File "simulator.ml", line 401, characters 24-32:
401 |                     let move_dst = movq [dest; Reg R15] m in 
                              ^^^^^^^^
Warning 26 [unused-var]: unused variable move_dst.
File "simulator.ml", line 402, characters 26-30:
402 |                       let mult = imulq (Reg R14) (Reg R15) m in 
                                ^^^^
Warning 26 [unused-var]: unused variable mult.
File "simulator.ml", line 404, characters 23-31:
404 |           | Orq -> let move_src = movq [src; Reg R14] m in
                             ^^^^^^^^
Warning 26 [unused-var]: unused variable move_src.
File "simulator.ml", line 405, characters 24-32:
405 |                     let move_dst = movq [dest; Reg R15] m in 
                              ^^^^^^^^
Warning 26 [unused-var]: unused variable move_dst.
File "simulator.ml", line 406, characters 26-32:
406 |                       let log_or = orq (Reg R14) (Reg R15) m in 
                                ^^^^^^
Warning 26 [unused-var]: unused variable log_or.
File "simulator.ml", line 474, characters 36-37:
474 |                                 let u = Array.set lbl_addr i (x.lbl, addr) in 
                                          ^
Warning 26 [unused-var]: unused variable u.
File "simulator.ml", line 478, characters 36-37:
478 |             | Data data_list -> let u = Array.set lbl_addr i (x.lbl, addr) in 
                                          ^
Warning 26 [unused-var]: unused variable u.
File "simulator.ml", line 544, characters 12-17:
544 |         let print = Array.iter (fun (x, y) -> Printf.printf "(%s,%d)" x (Int64.to_int y)) lbl_address in 
                  ^^^^^
Warning 26 [unused-var]: unused variable print.
File "simulator.ml", line 545, characters 14-19:
545 |           let print = Printf.printf " passed \n" in 
                    ^^^^^
Warning 26 [unused-var]: unused variable print.
File "simulator.ml", line 573, characters 13-21:
573 |       in let writetxt = Array.blit (Array.of_list text_seg) 0 mem (Option.get (map_addr(text_pos))) (List.length text_seg) 
                   ^^^^^^^^
Warning 26 [unused-var]: unused variable writetxt.
File "simulator.ml", line 574, characters 15-25:
574 |         in let write_data = Array.blit (Array.of_list data_seg) 0 mem (Option.get (map_addr(data_pos))) (List.length data_seg)
                     ^^^^^^^^^^
Warning 26 [unused-var]: unused variable write_data.
File "simulator.ml", line 580, characters 11-23:
580 |     in let update_stack =  copier(sbytes_of_int64 exit_addr) (Option.get(map_addr(Int64.sub mem_top 8L))) m
                 ^^^^^^^^^^^^
Warning 26 [unused-var]: unused variable update_stack.
File "simulator.ml", line 581, characters 13-23:
581 |       in let update_rip = (m.regs.(rind Rip) <- text_pos) 
                   ^^^^^^^^^^
Warning 26 [unused-var]: unused variable update_rip.
File "simulator.ml", line 582, characters 15-20:
582 |         in let u_rsp = (m.regs.(rind Rsp) <- Int64.sub mem_top 8L) in m
                     ^^^^^
Warning 26 [unused-var]: unused variable u_rsp.
# Target: gradedtests.cmo, tags: { package(num), byte, compile, extension:cmo, extension:ml, file:gradedtests.cmo, file:gradedtests.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package num -I util -I x86 -o gradedtests.cmo gradedtests.ml # cached
# Target: studenttests.ml.depends, tags: { package(num), extension:ml, file:studenttests.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules studenttests.ml > studenttests.ml.depends # cached
# Target: studenttests.cmo, tags: { package(num), byte, compile, extension:cmo, extension:ml, file:studenttests.cmo, file:studenttests.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package num -I util -I x86 -o studenttests.cmo studenttests.ml # cached
# Target: main.cmo, tags: { package(num), byte, compile, extension:cmo, extension:ml, file:main.cmo, file:main.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package num -I util -I x86 -o main.cmo main.ml # cached
# Target: util/assert.ml.depends, tags: { extension:ml, file:util/assert.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -modules util/assert.ml > util/assert.ml.depends # cached
# Target: util/assert.cmx, tags: { compile, extension:cmx, extension:ml, file:util/assert.cmx, file:util/assert.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -I util -I x86 -o util/assert.cmx util/assert.ml # cached
# Target: x86/x86.cmx, tags: { compile, extension:cmx, extension:ml, file:x86/x86.cmx, file:x86/x86.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -I x86 -I util -o x86/x86.cmx x86/x86.ml # cached
# Target: simulator.cmx, tags: { package(num), compile, extension:cmx, extension:ml, file:simulator.cmx, file:simulator.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -package num -I util -I x86 -o simulator.cmx simulator.ml
+ ocamlfind ocamlopt -c -package num -I util -I x86 -o simulator.cmx simulator.ml
File "simulator.ml", lines 185-190, characters 2-5:
185 | ..begin match o with
186 |     |Imm y -> invalid_arg "Dest shouldnt be imm bruh"
187 |     |Ind1 y -> (match y with | Lit l -> l | Lbl l -> failwith "Unresolved Label!")
188 |     |Ind2 y -> m.regs.(rind y)
189 |     |Ind3 (y, z) -> Int64.add (immer y) (m.regs.(rind z))
190 |   end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Reg _
File "simulator.ml", lines 233-235, characters 2-52:
233 | ..match b with
234 |     |x::[]-> m.mem.(addr) <- x  
235 |     |h::tl-> m.mem.(addr) <- h; copier tl (addr+1) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
[]
File "simulator.ml", lines 238-239, characters 2-35:
238 | ..match l with
239 |     |[x; y] -> store y (load x m) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 247-260, characters 2-11:
247 | ..match l with
248 |     |[x; y] ->
249 |       let src = load x m in
250 |       let dst = load y m in
251 |       let update = store y (Int64.add src dst) m in
...
257 |           else m.flags.fz <- false;
258 |           if (sign res = -1) then m.flags.fs <- true
259 |           else m.flags.fs <- false; 
260 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 263-276, characters 2-11:
263 | ..match l with
264 |     |[x; y] ->
265 |       let src = load x m in
266 |       let dst = load y m in
267 |       let update = store y (Int64.sub dst src) m in
...
273 |           else m.flags.fz <- false;
274 |           if (sign res = -1) then m.flags.fs <- true
275 |           else m.flags.fs <- false; 
276 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 278-285, characters 18-7:
278 | ..................(Reg y) (m:mach) : unit = 
279 |   let value = Int64.mul (m.regs.(rind x)) (m.regs.(rind y)) in
280 |     begin 
281 |       if ((sign (m.regs.(rind x)) <> sign ((m.regs.(rind y))) && sign(value) = 1) || (sign (m.regs.(rind x)) == sign ((m.regs.(rind y))) && sign(value) = -1)) 
282 |         then m.flags.fo <- true 
283 |       else m.flags.fo <- false; 
284 |       m.regs.(rind y) <- value;
285 |     end..
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 278-285, characters 10-7:
278 | ..........(Reg x) (Reg y) (m:mach) : unit = 
279 |   let value = Int64.mul (m.regs.(rind x)) (m.regs.(rind y)) in
280 |     begin 
281 |       if ((sign (m.regs.(rind x)) <> sign ((m.regs.(rind y))) && sign(value) = 1) || (sign (m.regs.(rind x)) == sign ((m.regs.(rind y))) && sign(value) = -1)) 
282 |         then m.flags.fo <- true 
283 |       else m.flags.fo <- false; 
284 |       m.regs.(rind y) <- value;
285 |     end..
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 294-306, characters 2-11:
294 | ..match l with
295 |     |[x; y] ->
296 |       let src = load x m in
297 |       let dst = load y m in
298 |       let update = store y (Int64.logand (load x m) (load y m)) m in
...
303 |           else m.flags.fz <- false;
304 |           if (sign res = -1) then m.flags.fs <- true
305 |           else m.flags.fs <- false; 
306 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 308-315, characters 16-9:
308 | ................(Reg y) (m:mach) : unit = 
309 |   let value = Int64.logor (m.regs.(rind x)) (m.regs.(rind y)) in 
310 |     let update = m.regs.(rind y) <- value  in
311 |       begin 
312 |         m.flags.fo <- false;
313 |         if (sign value = 0) then m.flags.fz <- true else m.flags.fz <- false;
314 |         if (sign value = -1) then m.flags.fs <- true else m.flags.fs <- false
315 |       end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 308-315, characters 8-9:
308 | ........(Reg x) (Reg y) (m:mach) : unit = 
309 |   let value = Int64.logor (m.regs.(rind x)) (m.regs.(rind y)) in 
310 |     let update = m.regs.(rind y) <- value  in
311 |       begin 
312 |         m.flags.fo <- false;
313 |         if (sign value = 0) then m.flags.fz <- true else m.flags.fz <- false;
314 |         if (sign value = -1) then m.flags.fs <- true else m.flags.fs <- false
315 |       end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 318-319, characters 2-79:
318 | ..match l with
319 |     |[x; y] -> store y (Int64.shift_left (load y m) (Int64.to_int(load x m))) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 322-323, characters 2-35:
322 | ..match l with
323 |     |[x; y] -> store y (load x m) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 343-365, characters 2-17:
343 | ..match l with 
344 |     |[src; dest] -> 
345 |       let move_src = movq [src; Reg R08] m in
346 |         let move_dst = movq [dest; Reg R09] m in 
347 |           let src_value = m.regs.(rind R08) in
...
362 |                 Printf.printf "%s" (Bool.to_string m.flags.fo);
363 |                 Printf.printf "%s" (Bool.to_string m.flags.fs);
364 |                 Printf.printf "%s\n" (Bool.to_string m.flags.fz);*)
365 |               end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 399-408, characters 10-13:
399 | ..........begin match opcode with 
400 |           |Imulq -> let move_src = movq [src; Reg R14] m in
401 |                     let move_dst = movq [dest; Reg R15] m in 
402 |                       let mult = imulq (Reg R14) (Reg R15) m in 
403 |                         movq [Reg R15; dest] m
404 |           | Orq -> let move_src = movq [src; Reg R14] m in
405 |                     let move_dst = movq [dest; Reg R15] m in 
406 |                       let log_or = orq (Reg R14) (Reg R15) m in 
407 |                         movq [Reg R15; dest] m
408 |           end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Movq|Pushq|Popq|Leaq|Incq|Decq|Negq|Notq|Addq|Subq|Xorq|Andq|Shlq|Sarq|Shrq|
Jmp|Cmpq|Callq|Retq|J _|Set _)
File "simulator.ml", line 242, characters 6-12:
242 |   let update = m.regs.(rind Rsp) <- (Int64.sub m.regs.(rind Rsp) 8L) in store (Ind2 Rsp) (load l m) m
            ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 251, characters 10-16:
251 |       let update = store y (Int64.add src dst) m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 267, characters 10-16:
267 |       let update = store y (Int64.sub dst src) m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 296, characters 10-13:
296 |       let src = load x m in
                ^^^
Warning 26 [unused-var]: unused variable src.
File "simulator.ml", line 297, characters 10-13:
297 |       let dst = load y m in
                ^^^
Warning 26 [unused-var]: unused variable dst.
File "simulator.ml", line 298, characters 10-16:
298 |       let update = store y (Int64.logand (load x m) (load y m)) m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 310, characters 8-14:
310 |     let update = m.regs.(rind y) <- value  in
              ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 326, characters 6-11:
326 |   let check =  if (Int64.equal (load l m) (Int64.min_int)) then m.flags.fo <- true 
            ^^^^^
Warning 26 [unused-var]: unused variable check.
File "simulator.ml", line 328, characters 6-9:
328 |   let not = notq l m in
            ^^^
Warning 26 [unused-var]: unused variable not.
File "simulator.ml", line 329, characters 6-12:
329 |   let update = store l (Int64.add (load l m) (1L)) m in
            ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 345, characters 10-18:
345 |       let move_src = movq [src; Reg R08] m in
                ^^^^^^^^
Warning 26 [unused-var]: unused variable move_src.
File "simulator.ml", line 346, characters 12-20:
346 |         let move_dst = movq [dest; Reg R09] m in 
                  ^^^^^^^^
Warning 26 [unused-var]: unused variable move_dst.
File "simulator.ml", line 349, characters 18-21:
349 |               let neg = negq (Reg R08) m in 
                        ^^^
Warning 26 [unused-var]: unused variable neg.
File "simulator.ml", line 380, characters 8-14:
380 |     let update = updater m in  
              ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 381, characters 10-13:
381 |       let mat = match instr with
                ^^^
Warning 26 [unused-var]: unused variable mat.
File "simulator.ml", line 400, characters 24-32:
400 |           |Imulq -> let move_src = movq [src; Reg R14] m in
                              ^^^^^^^^
Warning 26 [unused-var]: unused variable move_src.
File "simulator.ml", line 401, characters 24-32:
401 |                     let move_dst = movq [dest; Reg R15] m in 
                              ^^^^^^^^
Warning 26 [unused-var]: unused variable move_dst.
File "simulator.ml", line 402, characters 26-30:
402 |                       let mult = imulq (Reg R14) (Reg R15) m in 
                                ^^^^
Warning 26 [unused-var]: unused variable mult.
File "simulator.ml", line 404, characters 23-31:
404 |           | Orq -> let move_src = movq [src; Reg R14] m in
                             ^^^^^^^^
Warning 26 [unused-var]: unused variable move_src.
File "simulator.ml", line 405, characters 24-32:
405 |                     let move_dst = movq [dest; Reg R15] m in 
                              ^^^^^^^^
Warning 26 [unused-var]: unused variable move_dst.
File "simulator.ml", line 406, characters 26-32:
406 |                       let log_or = orq (Reg R14) (Reg R15) m in 
                                ^^^^^^
Warning 26 [unused-var]: unused variable log_or.
File "simulator.ml", line 474, characters 36-37:
474 |                                 let u = Array.set lbl_addr i (x.lbl, addr) in 
                                          ^
Warning 26 [unused-var]: unused variable u.
File "simulator.ml", line 478, characters 36-37:
478 |             | Data data_list -> let u = Array.set lbl_addr i (x.lbl, addr) in 
                                          ^
Warning 26 [unused-var]: unused variable u.
File "simulator.ml", line 544, characters 12-17:
544 |         let print = Array.iter (fun (x, y) -> Printf.printf "(%s,%d)" x (Int64.to_int y)) lbl_address in 
                  ^^^^^
Warning 26 [unused-var]: unused variable print.
File "simulator.ml", line 545, characters 14-19:
545 |           let print = Printf.printf " passed \n" in 
                    ^^^^^
Warning 26 [unused-var]: unused variable print.
File "simulator.ml", line 573, characters 13-21:
573 |       in let writetxt = Array.blit (Array.of_list text_seg) 0 mem (Option.get (map_addr(text_pos))) (List.length text_seg) 
                   ^^^^^^^^
Warning 26 [unused-var]: unused variable writetxt.
File "simulator.ml", line 574, characters 15-25:
574 |         in let write_data = Array.blit (Array.of_list data_seg) 0 mem (Option.get (map_addr(data_pos))) (List.length data_seg)
                     ^^^^^^^^^^
Warning 26 [unused-var]: unused variable write_data.
File "simulator.ml", line 580, characters 11-23:
580 |     in let update_stack =  copier(sbytes_of_int64 exit_addr) (Option.get(map_addr(Int64.sub mem_top 8L))) m
                 ^^^^^^^^^^^^
Warning 26 [unused-var]: unused variable update_stack.
File "simulator.ml", line 581, characters 13-23:
581 |       in let update_rip = (m.regs.(rind Rip) <- text_pos) 
                   ^^^^^^^^^^
Warning 26 [unused-var]: unused variable update_rip.
File "simulator.ml", line 582, characters 15-20:
582 |         in let u_rsp = (m.regs.(rind Rsp) <- Int64.sub mem_top 8L) in m
                     ^^^^^
Warning 26 [unused-var]: unused variable u_rsp.
# Target: gradedtests.cmx, tags: { package(num), compile, extension:cmx, extension:ml, file:gradedtests.cmx, file:gradedtests.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -package num -I util -I x86 -o gradedtests.cmx gradedtests.ml # cached
# Target: studenttests.cmx, tags: { package(num), compile, extension:cmx, extension:ml, file:studenttests.cmx, file:studenttests.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -package num -I util -I x86 -o studenttests.cmx studenttests.ml # cached
# Target: main.cmx, tags: { package(num), compile, extension:cmx, extension:ml, file:main.cmx, file:main.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -package num -I util -I x86 -o main.cmx main.ml # cached
# Target: main.native, tags: { package(num), dont_link_with, extension:native, file:main.native, link, native, ocaml, program, quiet, traverse }
ocamlfind ocamlopt unix.cmxa str.cmxa -linkpkg -package num -I x86 -I util x86/x86.cmx simulator.cmx util/assert.cmx gradedtests.cmx studenttests.cmx main.cmx -o main.native
# Compilation successful.
