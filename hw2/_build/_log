### Starting build.
# Target: main.ml.depends, tags: { package(num), extension:ml, file:main.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules main.ml > main.ml.depends # cached
# Target: util/assert.mli.depends, tags: { extension:mli, file:util/assert.mli, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -modules util/assert.mli > util/assert.mli.depends # cached
# Target: util/assert.cmi, tags: { byte, compile, extension:mli, file:util/assert.mli, interf, ocaml, quiet, traverse }
ocamlfind ocamlc -c -I util -I x86 -o util/assert.cmi util/assert.mli # cached
# Target: gradedtests.ml.depends, tags: { package(num), extension:ml, file:gradedtests.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules gradedtests.ml > gradedtests.ml.depends # cached
# Target: simulator.ml.depends, tags: { package(num), extension:ml, file:simulator.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules simulator.ml > simulator.ml.depends
# Target: x86/x86.ml.depends, tags: { extension:ml, file:x86/x86.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -modules x86/x86.ml > x86/x86.ml.depends # cached
# Target: x86/x86.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:x86/x86.cmo, file:x86/x86.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -I x86 -I util -o x86/x86.cmo x86/x86.ml # cached
# Target: simulator.cmo, tags: { package(num), byte, compile, extension:cmo, extension:ml, file:simulator.cmo, file:simulator.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package num -I util -I x86 -o simulator.cmo simulator.ml
+ ocamlfind ocamlc -c -package num -I util -I x86 -o simulator.cmo simulator.ml
File "simulator.ml", lines 180-185, characters 2-5:
180 | ..begin match o with
181 |     |Imm y -> invalid_arg "Dest shouldnt be imm bruh"
182 |     |Ind1 y -> (match y with | Lit l -> l | Lbl l -> failwith "Unresolved Label!")
183 |     |Ind2 y -> m.regs.(rind y)
184 |     |Ind3 (y, z) -> Int64.add (immer y) (m.regs.(rind z))
185 |   end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Reg _
File "simulator.ml", lines 242-255, characters 2-11:
242 | ..match l with
243 |     |[x; y] ->
244 |       let src = load x m in
245 |       let dst = load y m in
246 |       let update = store y (Int64.add src dst) m in
...
252 |           else m.flags.fz <- false;
253 |           if (sign res = -1) then m.flags.fs <- true
254 |           else m.flags.fs <- false; 
255 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 258-272, characters 2-11:
258 | ..match l with
259 |     |[x; y] ->
260 |       let src = load x m in
261 |       let dst = load y m in
262 |       let res = Int64.sub dst src in 
...
269 |           else m.flags.fz <- false;
270 |           if (sign res = -1) then m.flags.fs <- true
271 |           else m.flags.fs <- false; 
272 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 275-283, characters 2-7:
275 | ..match l with 
276 |     |[x; y] -> let src = load x m in
277 |                let dst = load y m in 
278 |                let value = Int64.mul src dst in
279 |     begin 
280 |       if ((sign (src) <> sign (dst) && sign(value) = 1) || (sign (src) == sign (dst) && sign(value) = -1)) then m.flags.fo <- true 
281 |       else m.flags.fo <- false; 
282 |       store y value m;
283 |     end..
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 292-304, characters 2-11:
292 | ..match l with
293 |     |[x; y] ->
294 |       let src = load x m in
295 |       let dst = load y m in
296 |       let update = store y (Int64.logand (load x m) (load y m)) m in
...
301 |           else m.flags.fz <- false;
302 |           if (sign res = -1) then m.flags.fs <- true
303 |           else m.flags.fs <- false; 
304 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 307-315, characters 2-11:
307 | ..match l with 
308 |     |[x; y] ->
309 |       let value = Int64.logor (load y m) (load x m) in 
310 |       let update = store y value m in
311 |         begin 
312 |           m.flags.fo <- false;
313 |           if (sign value = 0) then m.flags.fz <- true else m.flags.fz <- false;
314 |           if (sign value = -1) then m.flags.fs <- true else m.flags.fs <- false
315 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 318-321, characters 2-54:
318 | ..match l with 
319 |     |[x; y] -> 
320 |       let value = Int64.logxor (load y m) (load x m) in 
321 |       let update = store y value m in setflags value m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 324-329, characters 2-7:
324 | ..match l with
325 |     |[x; y] -> let value = Int64.shift_right (load y m) (Int64.to_int(load x m)) in store y value m;
326 |     begin 
327 |       if ((load x m) = 1L) then m.flags.fo <- false;
328 |       if ((load x m) <> 0L) then setflags value m;
329 |     end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 332-338, characters 2-7:
332 | ..match l with
333 |     |[x; y] -> let dest = (load y m) in 
334 |                let value = Int64.shift_left dest (Int64.to_int(load x m)) in store y value m;
335 |     begin 
336 |       if (((load x m) = 1L) && (Int64.shift_right_logical dest 63 <> (Int64.logand (Int64.shift_right_logical dest 62) 1L))) then m.flags.fo <- false;
337 |       if ((load x m) <> 0L) then setflags value m;
338 |     end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 341-348, characters 2-7:
341 | ..match l with
342 |     |[x; y] -> let dest = (load y m) in 
343 |                let value = Int64.shift_right_logical dest (Int64.to_int(load x m)) in 
344 |                let update = store y value m in
345 |     begin
346 |       if ((load x m) <> 0L) then setflags value m;
347 |       if ((load x m) = 1L) then m.flags.fo <- (Int64.shift_right_logical dest 63) = Int64.one;
348 |     end.
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 361-362, characters 2-39:
361 | ..match l with
362 |     |[x; y] -> store y (addrcalc x m) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 365-366, characters 2-35:
365 | ..match l with
366 |     |[x; y] -> store y (load x m) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 373-389, characters 2-17:
373 | ..match l with 
374 |     |[src; dest] -> 
375 |       let move_src = movq [src; Reg R08] m in
376 |         let move_dst = movq [dest; Reg R09] m in 
377 |           let src_value = m.regs.(rind R08) in
...
386 |                 else m.flags.fs <- false;
387 |                 if (sign res = 0) then m.flags.fz <- true 
388 |                 else m.flags.fz <- false;
389 |               end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", line 246, characters 10-16:
246 |       let update = store y (Int64.add src dst) m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 294, characters 10-13:
294 |       let src = load x m in
                ^^^
Warning 26 [unused-var]: unused variable src.
File "simulator.ml", line 295, characters 10-13:
295 |       let dst = load y m in
                ^^^
Warning 26 [unused-var]: unused variable dst.
File "simulator.ml", line 296, characters 10-16:
296 |       let update = store y (Int64.logand (load x m) (load y m)) m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 310, characters 10-16:
310 |       let update = store y value m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 321, characters 10-16:
321 |       let update = store y value m in setflags value m
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 344, characters 19-25:
344 |                let update = store y value m in
                         ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 354, characters 6-11:
354 |   let check =  if (Int64.equal (load l m) (Int64.min_int)) then m.flags.fo <- true 
            ^^^^^
Warning 26 [unused-var]: unused variable check.
File "simulator.ml", line 356, characters 6-9:
356 |   let not = notq l m in
            ^^^
Warning 26 [unused-var]: unused variable not.
File "simulator.ml", line 357, characters 6-12:
357 |   let update = store l (Int64.add (load l m) (1L)) m in
            ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 375, characters 10-18:
375 |       let move_src = movq [src; Reg R08] m in
                ^^^^^^^^
Warning 26 [unused-var]: unused variable move_src.
File "simulator.ml", line 376, characters 12-20:
376 |         let move_dst = movq [dest; Reg R09] m in 
                  ^^^^^^^^
Warning 26 [unused-var]: unused variable move_dst.
File "simulator.ml", line 379, characters 18-21:
379 |               let neg = negq (Reg R08) m in 
                        ^^^
Warning 26 [unused-var]: unused variable neg.
File "simulator.ml", line 404, characters 8-14:
404 |     let update = updater m in 
              ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 487, characters 36-37:
487 |                                 let u = Array.set lbl_addr i (x.lbl, addr) in 
                                          ^
Warning 26 [unused-var]: unused variable u.
File "simulator.ml", line 491, characters 36-37:
491 |             | Data data_list -> let u = Array.set lbl_addr i (x.lbl, addr) in 
                                          ^
Warning 26 [unused-var]: unused variable u.
File "simulator.ml", line 584, characters 13-21:
584 |       in let writetxt = Array.blit (Array.of_list text_seg) 0 mem (Option.get (map_addr(text_pos))) (List.length text_seg) 
                   ^^^^^^^^
Warning 26 [unused-var]: unused variable writetxt.
File "simulator.ml", line 585, characters 15-25:
585 |         in let write_data = Array.blit (Array.of_list data_seg) 0 mem (Option.get (map_addr(data_pos))) (List.length data_seg)
                     ^^^^^^^^^^
Warning 26 [unused-var]: unused variable write_data.
File "simulator.ml", line 591, characters 11-23:
591 |     in let update_stack =  store (Ind1 (Lit (Int64.sub mem_top 8L))) exit_addr m
                 ^^^^^^^^^^^^
Warning 26 [unused-var]: unused variable update_stack.
File "simulator.ml", line 592, characters 13-23:
592 |       in let update_rip = (m.regs.(rind Rip) <- entry) 
                   ^^^^^^^^^^
Warning 26 [unused-var]: unused variable update_rip.
File "simulator.ml", line 593, characters 15-20:
593 |         in let u_rsp = (m.regs.(rind Rsp) <- Int64.sub mem_top 8L) in m
                     ^^^^^
Warning 26 [unused-var]: unused variable u_rsp.
# Target: studenttests.ml.depends, tags: { package(num), extension:ml, file:studenttests.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules studenttests.ml > studenttests.ml.depends # cached
# Target: gradedtests.cmo, tags: { package(num), byte, compile, extension:cmo, extension:ml, file:gradedtests.cmo, file:gradedtests.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package num -I util -I x86 -o gradedtests.cmo gradedtests.ml
# Target: studenttests.cmo, tags: { package(num), byte, compile, extension:cmo, extension:ml, file:studenttests.cmo, file:studenttests.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package num -I util -I x86 -o studenttests.cmo studenttests.ml
# Target: main.cmo, tags: { package(num), byte, compile, extension:cmo, extension:ml, file:main.cmo, file:main.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package num -I util -I x86 -o main.cmo main.ml
# Target: util/assert.ml.depends, tags: { extension:ml, file:util/assert.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -modules util/assert.ml > util/assert.ml.depends # cached
# Target: util/assert.cmx, tags: { compile, extension:cmx, extension:ml, file:util/assert.cmx, file:util/assert.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -I util -I x86 -o util/assert.cmx util/assert.ml # cached
# Target: x86/x86.cmx, tags: { compile, extension:cmx, extension:ml, file:x86/x86.cmx, file:x86/x86.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -I x86 -I util -o x86/x86.cmx x86/x86.ml # cached
# Target: simulator.cmx, tags: { package(num), compile, extension:cmx, extension:ml, file:simulator.cmx, file:simulator.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -package num -I util -I x86 -o simulator.cmx simulator.ml
+ ocamlfind ocamlopt -c -package num -I util -I x86 -o simulator.cmx simulator.ml
File "simulator.ml", lines 180-185, characters 2-5:
180 | ..begin match o with
181 |     |Imm y -> invalid_arg "Dest shouldnt be imm bruh"
182 |     |Ind1 y -> (match y with | Lit l -> l | Lbl l -> failwith "Unresolved Label!")
183 |     |Ind2 y -> m.regs.(rind y)
184 |     |Ind3 (y, z) -> Int64.add (immer y) (m.regs.(rind z))
185 |   end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Reg _
File "simulator.ml", lines 242-255, characters 2-11:
242 | ..match l with
243 |     |[x; y] ->
244 |       let src = load x m in
245 |       let dst = load y m in
246 |       let update = store y (Int64.add src dst) m in
...
252 |           else m.flags.fz <- false;
253 |           if (sign res = -1) then m.flags.fs <- true
254 |           else m.flags.fs <- false; 
255 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 258-272, characters 2-11:
258 | ..match l with
259 |     |[x; y] ->
260 |       let src = load x m in
261 |       let dst = load y m in
262 |       let res = Int64.sub dst src in 
...
269 |           else m.flags.fz <- false;
270 |           if (sign res = -1) then m.flags.fs <- true
271 |           else m.flags.fs <- false; 
272 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 275-283, characters 2-7:
275 | ..match l with 
276 |     |[x; y] -> let src = load x m in
277 |                let dst = load y m in 
278 |                let value = Int64.mul src dst in
279 |     begin 
280 |       if ((sign (src) <> sign (dst) && sign(value) = 1) || (sign (src) == sign (dst) && sign(value) = -1)) then m.flags.fo <- true 
281 |       else m.flags.fo <- false; 
282 |       store y value m;
283 |     end..
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 292-304, characters 2-11:
292 | ..match l with
293 |     |[x; y] ->
294 |       let src = load x m in
295 |       let dst = load y m in
296 |       let update = store y (Int64.logand (load x m) (load y m)) m in
...
301 |           else m.flags.fz <- false;
302 |           if (sign res = -1) then m.flags.fs <- true
303 |           else m.flags.fs <- false; 
304 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 307-315, characters 2-11:
307 | ..match l with 
308 |     |[x; y] ->
309 |       let value = Int64.logor (load y m) (load x m) in 
310 |       let update = store y value m in
311 |         begin 
312 |           m.flags.fo <- false;
313 |           if (sign value = 0) then m.flags.fz <- true else m.flags.fz <- false;
314 |           if (sign value = -1) then m.flags.fs <- true else m.flags.fs <- false
315 |         end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 318-321, characters 2-54:
318 | ..match l with 
319 |     |[x; y] -> 
320 |       let value = Int64.logxor (load y m) (load x m) in 
321 |       let update = store y value m in setflags value m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 324-329, characters 2-7:
324 | ..match l with
325 |     |[x; y] -> let value = Int64.shift_right (load y m) (Int64.to_int(load x m)) in store y value m;
326 |     begin 
327 |       if ((load x m) = 1L) then m.flags.fo <- false;
328 |       if ((load x m) <> 0L) then setflags value m;
329 |     end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 332-338, characters 2-7:
332 | ..match l with
333 |     |[x; y] -> let dest = (load y m) in 
334 |                let value = Int64.shift_left dest (Int64.to_int(load x m)) in store y value m;
335 |     begin 
336 |       if (((load x m) = 1L) && (Int64.shift_right_logical dest 63 <> (Int64.logand (Int64.shift_right_logical dest 62) 1L))) then m.flags.fo <- false;
337 |       if ((load x m) <> 0L) then setflags value m;
338 |     end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 341-348, characters 2-7:
341 | ..match l with
342 |     |[x; y] -> let dest = (load y m) in 
343 |                let value = Int64.shift_right_logical dest (Int64.to_int(load x m)) in 
344 |                let update = store y value m in
345 |     begin
346 |       if ((load x m) <> 0L) then setflags value m;
347 |       if ((load x m) = 1L) then m.flags.fo <- (Int64.shift_right_logical dest 63) = Int64.one;
348 |     end.
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 361-362, characters 2-39:
361 | ..match l with
362 |     |[x; y] -> store y (addrcalc x m) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 365-366, characters 2-35:
365 | ..match l with
366 |     |[x; y] -> store y (load x m) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", lines 373-389, characters 2-17:
373 | ..match l with 
374 |     |[src; dest] -> 
375 |       let move_src = movq [src; Reg R08] m in
376 |         let move_dst = movq [dest; Reg R09] m in 
377 |           let src_value = m.regs.(rind R08) in
...
386 |                 else m.flags.fs <- false;
387 |                 if (sign res = 0) then m.flags.fz <- true 
388 |                 else m.flags.fz <- false;
389 |               end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::_::_::_
File "simulator.ml", line 246, characters 10-16:
246 |       let update = store y (Int64.add src dst) m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 294, characters 10-13:
294 |       let src = load x m in
                ^^^
Warning 26 [unused-var]: unused variable src.
File "simulator.ml", line 295, characters 10-13:
295 |       let dst = load y m in
                ^^^
Warning 26 [unused-var]: unused variable dst.
File "simulator.ml", line 296, characters 10-16:
296 |       let update = store y (Int64.logand (load x m) (load y m)) m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 310, characters 10-16:
310 |       let update = store y value m in
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 321, characters 10-16:
321 |       let update = store y value m in setflags value m
                ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 344, characters 19-25:
344 |                let update = store y value m in
                         ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 354, characters 6-11:
354 |   let check =  if (Int64.equal (load l m) (Int64.min_int)) then m.flags.fo <- true 
            ^^^^^
Warning 26 [unused-var]: unused variable check.
File "simulator.ml", line 356, characters 6-9:
356 |   let not = notq l m in
            ^^^
Warning 26 [unused-var]: unused variable not.
File "simulator.ml", line 357, characters 6-12:
357 |   let update = store l (Int64.add (load l m) (1L)) m in
            ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 375, characters 10-18:
375 |       let move_src = movq [src; Reg R08] m in
                ^^^^^^^^
Warning 26 [unused-var]: unused variable move_src.
File "simulator.ml", line 376, characters 12-20:
376 |         let move_dst = movq [dest; Reg R09] m in 
                  ^^^^^^^^
Warning 26 [unused-var]: unused variable move_dst.
File "simulator.ml", line 379, characters 18-21:
379 |               let neg = negq (Reg R08) m in 
                        ^^^
Warning 26 [unused-var]: unused variable neg.
File "simulator.ml", line 404, characters 8-14:
404 |     let update = updater m in 
              ^^^^^^
Warning 26 [unused-var]: unused variable update.
File "simulator.ml", line 487, characters 36-37:
487 |                                 let u = Array.set lbl_addr i (x.lbl, addr) in 
                                          ^
Warning 26 [unused-var]: unused variable u.
File "simulator.ml", line 491, characters 36-37:
491 |             | Data data_list -> let u = Array.set lbl_addr i (x.lbl, addr) in 
                                          ^
Warning 26 [unused-var]: unused variable u.
File "simulator.ml", line 584, characters 13-21:
584 |       in let writetxt = Array.blit (Array.of_list text_seg) 0 mem (Option.get (map_addr(text_pos))) (List.length text_seg) 
                   ^^^^^^^^
Warning 26 [unused-var]: unused variable writetxt.
File "simulator.ml", line 585, characters 15-25:
585 |         in let write_data = Array.blit (Array.of_list data_seg) 0 mem (Option.get (map_addr(data_pos))) (List.length data_seg)
                     ^^^^^^^^^^
Warning 26 [unused-var]: unused variable write_data.
File "simulator.ml", line 591, characters 11-23:
591 |     in let update_stack =  store (Ind1 (Lit (Int64.sub mem_top 8L))) exit_addr m
                 ^^^^^^^^^^^^
Warning 26 [unused-var]: unused variable update_stack.
File "simulator.ml", line 592, characters 13-23:
592 |       in let update_rip = (m.regs.(rind Rip) <- entry) 
                   ^^^^^^^^^^
Warning 26 [unused-var]: unused variable update_rip.
File "simulator.ml", line 593, characters 15-20:
593 |         in let u_rsp = (m.regs.(rind Rsp) <- Int64.sub mem_top 8L) in m
                     ^^^^^
Warning 26 [unused-var]: unused variable u_rsp.
# Target: gradedtests.cmx, tags: { package(num), compile, extension:cmx, extension:ml, file:gradedtests.cmx, file:gradedtests.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -package num -I util -I x86 -o gradedtests.cmx gradedtests.ml
# Target: studenttests.cmx, tags: { package(num), compile, extension:cmx, extension:ml, file:studenttests.cmx, file:studenttests.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -package num -I util -I x86 -o studenttests.cmx studenttests.ml
# Target: main.cmx, tags: { package(num), compile, extension:cmx, extension:ml, file:main.cmx, file:main.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -package num -I util -I x86 -o main.cmx main.ml
# Target: main.native, tags: { package(num), dont_link_with, extension:native, file:main.native, link, native, ocaml, program, quiet, traverse }
ocamlfind ocamlopt unix.cmxa str.cmxa -linkpkg -package num -I x86 -I util x86/x86.cmx simulator.cmx util/assert.cmx gradedtests.cmx studenttests.cmx main.cmx -o main.native
# Compilation successful.
