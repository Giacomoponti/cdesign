### Starting build.
# Target: main.ml.depends, tags: { package(num), extension:ml, file:main.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules main.ml > main.ml.depends # cached
# Target: util/assert.mli.depends, tags: { extension:mli, file:util/assert.mli, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -modules util/assert.mli > util/assert.mli.depends # cached
# Target: util/assert.cmi, tags: { byte, compile, extension:mli, file:util/assert.mli, interf, ocaml, quiet, traverse }
ocamlfind ocamlc -c -I util -I x86 -o util/assert.cmi util/assert.mli # cached
# Target: gradedtests.ml.depends, tags: { package(num), extension:ml, file:gradedtests.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules gradedtests.ml > gradedtests.ml.depends # cached
# Target: simulator.ml.depends, tags: { package(num), extension:ml, file:simulator.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules simulator.ml > simulator.ml.depends
# Target: x86/x86.ml.depends, tags: { extension:ml, file:x86/x86.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -modules x86/x86.ml > x86/x86.ml.depends # cached
# Target: x86/x86.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:x86/x86.cmo, file:x86/x86.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -I x86 -I util -o x86/x86.cmo x86/x86.ml # cached
# Target: simulator.cmo, tags: { package(num), byte, compile, extension:cmo, extension:ml, file:simulator.cmo, file:simulator.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package num -I util -I x86 -o simulator.cmo simulator.ml
+ ocamlfind ocamlc -c -package num -I util -I x86 -o simulator.cmo simulator.ml
File "simulator.ml", lines 228-234, characters 2-5:
228 | ..begin match l with
229 |     |[x; Imm y] -> invalid_arg "Immediate cannot be a location"
230 |     |[x; Reg y] -> (m.regs.(rind y) <- decosrc x m)
231 |     |[x; Ind1 y] -> (m.mem.(Option.get (map_addr(immer y))) <- List.hd@@sbytes_of_int64 (decosrc x m))
232 |     |[x; Ind2 y] -> (m.mem.(Option.get (map_addr((m.regs.(rind y))))) <- List.hd@@sbytes_of_int64 (decosrc x m))
233 |     |[x; Ind3 (y, z)] -> (m.mem.(Option.get@@map_addr (Int64.add (immer y) (m.regs.(rind z)))) <- List.hd@@sbytes_of_int64(decosrc x m))
234 |   end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::Imm _::_::_
File "simulator.ml", lines 282-284, characters 4-54:
282 | ....match b with
283 |       |x::[]-> m.mem.(addr) <- x  
284 |       |h::tl-> m.mem.(addr) <- h; copier tl (addr+1) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
[]
File "simulator.ml", line 289, characters 56-76:
289 |       |[x; Ind1 y] -> copier (sbytes_of_int64(Int64.sub (decodst (Ind1 y) m) (decosrc x m))) (Option.get (map_addr(immer y))) m
                                                              ^^^^^^^^^^^^^^^^^^^^
Error: This expression has type sbyte but an expression was expected of type
         int64
Command exited with code 2.
# Compilation unsuccessful.
