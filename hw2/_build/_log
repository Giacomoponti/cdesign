### Starting build.
# Target: main.ml.depends, tags: { package(num), extension:ml, file:main.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules main.ml > main.ml.depends # cached
# Target: util/assert.mli.depends, tags: { extension:mli, file:util/assert.mli, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -modules util/assert.mli > util/assert.mli.depends # cached
# Target: util/assert.cmi, tags: { byte, compile, extension:mli, file:util/assert.mli, interf, ocaml, quiet, traverse }
ocamlfind ocamlc -c -I util -I x86 -o util/assert.cmi util/assert.mli # cached
# Target: gradedtests.ml.depends, tags: { package(num), extension:ml, file:gradedtests.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules gradedtests.ml > gradedtests.ml.depends # cached
# Target: simulator.ml.depends, tags: { package(num), extension:ml, file:simulator.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package num -modules simulator.ml > simulator.ml.depends
# Target: x86/x86.ml.depends, tags: { extension:ml, file:x86/x86.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -modules x86/x86.ml > x86/x86.ml.depends # cached
# Target: x86/x86.cmo, tags: { byte, compile, extension:cmo, extension:ml, file:x86/x86.cmo, file:x86/x86.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -I x86 -I util -o x86/x86.cmo x86/x86.ml # cached
# Target: simulator.cmo, tags: { package(num), byte, compile, extension:cmo, extension:ml, file:simulator.cmo, file:simulator.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -package num -I util -I x86 -o simulator.cmo simulator.ml
+ ocamlfind ocamlc -c -package num -I util -I x86 -o simulator.cmo simulator.ml
File "simulator.ml", lines 228-234, characters 2-5:
228 | ..begin match l with
229 |     |[x; Imm y] -> invalid_arg "Immediate cannot be a location"
230 |     |[x; Reg y] -> (m.regs.(rind y) <- decosrc x m)
231 |     |[x; Ind1 y] -> (m.mem.(Option.get (map_addr(immer y))) <- List.hd@@sbytes_of_int64 (decosrc x m))
232 |     |[x; Ind2 y] -> (m.mem.(Option.get (map_addr((m.regs.(rind y))))) <- List.hd@@sbytes_of_int64 (decosrc x m))
233 |     |[x; Ind3 (y, z)] -> (m.mem.(Option.get@@map_addr (Int64.add (immer y) (m.regs.(rind z)))) <- List.hd@@sbytes_of_int64(decosrc x m))
234 |   end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::Imm _::_::_
File "simulator.ml", lines 283-285, characters 4-54:
283 | ....match b with
284 |       |x::[]-> m.mem.(addr) <- x  
285 |       |h::tl-> m.mem.(addr) <- h; copier tl (addr+1) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
[]
File "simulator.ml", lines 288-292, characters 4-174:
288 | ....match l with
289 |       |[x; Reg y] -> m.regs.(rind y) <- Int64.sub (m.regs.(rind y)) (decosrc x m)
290 |       |[x; Ind1 y] -> copier (sbytes_of_int64(Int64.sub (decosrc (Ind1 y) m) (decosrc x m))) (Option.get (map_addr(immer y))) m
291 |       |[x; Ind2 y] -> copier (sbytes_of_int64(Int64.sub (decosrc (Ind2 y) m) (decosrc x m))) (Option.get (map_addr((m.regs.(rind y))))) m
292 |       |[x; Ind3 (y, z)] -> copier (sbytes_of_int64(Int64.sub (decosrc (Ind3 (y, z)) m) (decosrc x m))) (Int64.to_int (immer y) + (Option.get (map_addr((m.regs.(rind z)))))) m
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
_::Reg _::_::_
File "simulator.ml", lines 319-326, characters 17-9:
319 | .................(Reg y) (m:mach) : unit = 
320 |   let value = Int64.logand (m.regs.(rind x)) (m.regs.(rind y)) in 
321 |     let update = m.regs.(rind y) <- value  in
322 |       begin 
323 |         m.flags.fo <- false;
324 |         if (sign value = 0) then m.flags.fz <- true else m.flags.fz <- false;
325 |         if (sign value = -1) then m.flags.fs <- true else m.flags.fs <- false
326 |       end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 319-326, characters 9-9:
319 | .........(Reg x) (Reg y) (m:mach) : unit = 
320 |   let value = Int64.logand (m.regs.(rind x)) (m.regs.(rind y)) in 
321 |     let update = m.regs.(rind y) <- value  in
322 |       begin 
323 |         m.flags.fo <- false;
324 |         if (sign value = 0) then m.flags.fz <- true else m.flags.fz <- false;
325 |         if (sign value = -1) then m.flags.fs <- true else m.flags.fs <- false
326 |       end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 327-334, characters 16-9:
327 | ................(Reg y) (m:mach) : unit = 
328 |   let value = Int64.logor (m.regs.(rind x)) (m.regs.(rind y)) in 
329 |     let update = m.regs.(rind y) <- value  in
330 |       begin 
331 |         m.flags.fo <- false;
332 |         if (sign value = 0) then m.flags.fz <- true else m.flags.fz <- false;
333 |         if (sign value = -1) then m.flags.fs <- true else m.flags.fs <- false
334 |       end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 327-334, characters 8-9:
327 | ........(Reg x) (Reg y) (m:mach) : unit = 
328 |   let value = Int64.logor (m.regs.(rind x)) (m.regs.(rind y)) in 
329 |     let update = m.regs.(rind y) <- value  in
330 |       begin 
331 |         m.flags.fo <- false;
332 |         if (sign value = 0) then m.flags.fz <- true else m.flags.fz <- false;
333 |         if (sign value = -1) then m.flags.fs <- true else m.flags.fs <- false
334 |       end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 336-343, characters 18-7:
336 | ..................(Reg y) (m:mach) : unit = 
337 |   let value = Int64.mul (m.regs.(rind x)) (m.regs.(rind y)) in
338 |     begin 
339 |       if ((sign (m.regs.(rind x)) <> sign ((m.regs.(rind y))) && sign(value) = 1) || (sign (m.regs.(rind x)) == sign ((m.regs.(rind y))) && sign(value) = -1)) 
340 |         then m.flags.fo <- true 
341 |       else m.flags.fo <- false; 
342 |       m.regs.(rind y) <- value;
343 |     end..
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 336-343, characters 10-7:
336 | ..........(Reg x) (Reg y) (m:mach) : unit = 
337 |   let value = Int64.mul (m.regs.(rind x)) (m.regs.(rind y)) in
338 |     begin 
339 |       if ((sign (m.regs.(rind x)) <> sign ((m.regs.(rind y))) && sign(value) = 1) || (sign (m.regs.(rind x)) == sign ((m.regs.(rind y))) && sign(value) = -1)) 
340 |         then m.flags.fo <- true 
341 |       else m.flags.fo <- false; 
342 |       m.regs.(rind y) <- value;
343 |     end..
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 345-346, characters 17-86:
345 | .................(Reg y) (m:mach) : unit =
346 |   m.regs.(rind y) <- Int64.shift_left (m.regs.(rind y)) (Int64.to_int m.regs.(rind x))..
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 345-346, characters 9-86:
345 | .........(Reg x) (Reg y) (m:mach) : unit =
346 |   m.regs.(rind y) <- Int64.shift_left (m.regs.(rind y)) (Int64.to_int m.regs.(rind x))..
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 348-367, characters 17-9:
348 | .................(Reg y) (m:mach) =
349 |   let src_value = m.regs.(rind x) in
350 |     let dst_value = m.regs.(rind y) in
351 |       let neg = negq (Reg x) m in 
352 |         let neg_src = m.regs.(rind x) in 
...
364 |         Printf.printf "%s" (Bool.to_string m.flags.fo);
365 |         Printf.printf "%s" (Bool.to_string m.flags.fs);
366 |         Printf.printf "%s\n" (Bool.to_string m.flags.fz);
367 |       end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", lines 348-367, characters 9-9:
348 | .........(Reg x) (Reg y) (m:mach) =
349 |   let src_value = m.regs.(rind x) in
350 |     let dst_value = m.regs.(rind y) in
351 |       let neg = negq (Reg x) m in 
352 |         let neg_src = m.regs.(rind x) in 
...
364 |         Printf.printf "%s" (Bool.to_string m.flags.fo);
365 |         Printf.printf "%s" (Bool.to_string m.flags.fs);
366 |         Printf.printf "%s\n" (Bool.to_string m.flags.fz);
367 |       end
Warning 8 [partial-match]: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Imm _|Ind1 _|Ind2 _|Ind3 (_, _))
File "simulator.ml", line 473, characters 47-80:
473 |         | text -> if(exe.entry = mem_bot) then exe.entry <- Int64.add mem_bot 8L 
                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
Error: The record field entry is not mutable
Command exited with code 2.
# Compilation unsuccessful.
